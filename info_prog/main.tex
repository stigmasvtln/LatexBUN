\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\title{Пример алгоритма димамического программирования}
\author{Светлана Кляулина}
\date{}

\begin{document}

\maketitle
Поговорим мы про 
динамическое программирование на примере 
задачи про наибольшую общую 
подпоследовательность. 

У нас есть две последовательности чисел. И мы 
хотим найти их общую последовательность наибольшей длины.

Значит вот, пример у нас на слайде, и соответственно последовательность  А (1,2,3,4,5) и пусть последовательность 
В - (5,1,3,2,4). И,  собственно, у нее, у этих двух последовательностей есть две общие подпоследовательности  наибольшей длины, (1,3,4) и (1,2,4).
Обратите внимание, что при удалении, когда мы из последовательности  
получаем подпоследовательность, элементы местами не меняются. Таким образом,  как бы понятно. Несмотря на то, что состоят А и В, по сути, из одинаковых элементов,  мы берем именно слева направо, как оно идет. 

Как же решать эту задачу с помощью метода  
динамического программирования. Ответим на пять вопросов.

Во-первых, мы должны понять, что хранить в ДП. 
В данном случае мы заведем двумерный массив, в котором в элементе  i итое джитое мы будем хранить наибольшую общую подпоследовательность между первыми i (и) элементами последовательности А и  первыми j (джи) элементами последовательности В. То есть будем решаем задачу на префиксах. 
База - базой послужит ....
В данном случае мы знаем, что если мы из последовательности А возьмем   первые ноль элементов и из последовательности В возьмем первые ноль элементов, то, абсолютно  внезапно, у пустых последовательностей 
наибольшая общая подпоследовательность  тоже пустая. И длина тоже будет ноль. 

Дальше переход, 
Мы хотим решить задачу для префиксов, соответственно, [i] и [j] для наших двух последовательностей. При этом мы говорим, что для всех предыдущих префиксов мы это, скорее всего, уже будем знать. Так у нас  
будет разбиваться на подзадачи. Соответственно, 
план такой - у нас есть два стула: на первом стуле  
это если у нас [i]-элемент в последовательности 
А, совпадает с [j]-элементом в последовательности  

В. Что это тогда значит? Это значит, что их можно 
друг на друга "заматчить" и свести задачу к тому,  

что давайте вот эти элементы, мы возьмем 
его как последний элемент наибольшей  
общей подпоследовательности. 
А как начало наибольшей общей  
подпоследовательности мы возьмем для задачи на 
[i-1] и [j-1] префиксе. То бишь, соответственно,  
это значение у нас лежит в dp [i-1] [j-1], как мы 
знаем. В случае, если у вас последние символы не  
равны, то в любом случае гарантированно один из 
них не войдет в ответ для [i]- и [j]- префикса.  
Собственно из этого получаем простую формулу, 
да, обратите внимание, что если у нас [i]-символ,  
который, я напоминаю, у нас ноль-индексация, 
стоит в позиции [i-1] у последовательности  

А равен [j]-символу В, то тогда мы можем 
взять как ответ dp [i-1] [j-1] + 1. Иначе  

нам придется один из этих символов откусить. 
Что тогда нам остается? Ну, мы, вроде как,  

максимизируем ответ, то мы возьмем максимум 
из dp [i-1] [j], dp [i] [j-1]. Значит тут  

мы подходим к следующему моменту, мы берем, и 
нам надо понять в каком порядке нам вычислять 

значение dp [i] [j]. Многие, возможно, знают про 
ленивую динамику, но мы пойдем немножко дальше и  

все-таки обсудим, а что нам делать с ответом. 
Чтоб посчитать значение в состоянии [i] [j],  

то бишь dp [i] [j], нам нужно знать значение [i-1] 
[j-1], [i-1] [j], [i] [j-1]. В данном случае все  

довольно просто. Мы можем взять и позволить себе 
выбирать i по возрастанию и j тоже по возрастанию.  

Прошу обратить внимание, что мы уже почти все 
задачу решили, а не написал ни строчки кода,  

и это все на самом деле специально. Потому что 
в некоторых задачах надо сначала думать, а потом  

делать, ну, как в принципе и по жизни. Собственно, 
и последнее, что нам нужно понять, это где будет  

ответ. Отлично, мы посчитали таблицу, но нас же 
просят найти, например, длину наибольшей общей  

подпоследовательности. Где мы её достанем? Опять 
же, конкретно в данной задаче все довольно просто.  

Как мы в dp [i] [j] хранили длину наибольшей 
общей подпоследовательности на двух префиксах  

наших последовательностей. Давайте возьмем, 
собственно, на максимальных префиксах, то есть  

возьмем dp [m] - это просто по нашему определению 
длина наибольшей общей подпоследовательности всей  

А и всей последовательности В. Давайте, посмотрев 
как мы плавненько расписали пять пунктов, которые  

мы могли бы расписать на бумажке, возьмем и просто 
напишем код.
\end{document}
